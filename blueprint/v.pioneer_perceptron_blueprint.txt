기본 설계

[입력]
- 특징 벡터: X1, X2, ..., Xd

[가중합]
- Z = Σ(k=1..d) X_k * w_k  (w_k: 각 X_k에 대응하는 가중치)

[발화 기준]
- 발화 역치 SP

[판정]
- Z ≥ SP  → 발화
- Z < SP  → 비발화 → f_g·Z 계산하지 않음(출력 없음)

[발화한 경우의 출력/전달]
- 활성화: Y_g = f_g · Z,  g = 1..α
  (α: 현재 퍼셉트론의 출력이 연결되는 다음 퍼셉트론의 수)
- 출력 벡터: Y = [Y_1, Y_2, ..., Y_α]

A안.
발화 통계의 자가안정과 단순 규칙 구현 설계.

[학습/적응]
- 표기: [u]_+ = max(u, 0),  clip(a,l,h)=min(max(a,l),h)
- 보조변수: F = 1[Z ≥ SP]

1) 입력 가중치 w_k
  Δw_k = η₊ [Z−SP]_+ X_k (1 − w_k/w_max) − η₋ [SP−Z]_+ X_k (w_k/w_max)
  w_k ← clip(w_k + Δw_k, 0, w_max)

2) 출력 가중치 f_g
  Δf_g = ρ₊ F · (Z/Z_max) · (1 − f_g/f_max) − ρ₋ (1−F) · (f_g/f_max)
  f_g ← clip(f_g + Δf_g, 0, f_max)

3) 발화 역치 SP (홈오스테틱)
  \bar F ← (1−β) \bar F + β F
  SP ← SP + η_SP (\bar F − r*)

- 파라미터:
  η₊      > 입력 가중치 강화(발화 시) 학습률
  η₋      > 입력 가중치 약화(비발화 시) 학습률
  ρ₊      > 출력 가중치 f_g 강화 학습률
  ρ₋      > 출력 가중치 f_g 약화 학습률
  η_SP    > 발화 역치 SP 홈오스테틱 조절 학습률
  w_max   > 입력 가중치 상한(포화값)
  f_max   > 출력 가중치 상한(포화값)
  Z_max   > Z 정규화 상수(스케일 기준)
  β ∈ (0,1]   > 발화율 지수이동평균(EMA) 계수(클수록 최근 값 반영↑)
  r* ∈ [0,1]  > 목표 발화율

---------------------------------------------------------------------------------

B안.
역전파로 정확히 크레딧 할당되고, Oja가 그 위에서 규제 역할을 함.

[순전파]
Z = Σ_k X_k · w_k
F = 1[ Z ≥ SP ]
Y_g = F · f_g · Z    // g = 1..α

[역전파]  // 상류 기울기 δ_g = ∂L/∂Y_g 가 주어졌다고 가정
S = Σ_g (δ_g · f_g)

∂L/∂f_g = δ_g · F · Z
∂L/∂Z   = F · S
∂L/∂w_k = (∂L/∂Z) · X_k = F · S · X_k
// SP는 기울기 사용 안 함(하드 게이트), 아래 홈오스테틱으로만 업데이트

[업데이트]
clip(a,l,h) = min(max(a,l), h)

1) 입력 가중치 w_k  (역전파 + Oja 정규화, 발화 시만)
Δw_k(bp)  = - η_bp,w · ∂L/∂w_k
Δw_k(oja) =  F · η_w · ( Z · X_k  −  (Z^2 / Z_ref^2) · w_k )
w_k ← clip( w_k + Δw_k(bp) + Δw_k(oja),  0, w_max )

2) 출력 가중치 f_g  (역전파 + Oja 정규화, 발화 시만)
Δf_g(bp)  = - η_bp,f · ∂L/∂f_g  = - η_bp,f · (δ_g · F · Z)
Δf_g(oja) =  F · η_f · ( Y_g · Z  −  (Y_g^2 / Y_ref^2) · f_g )
f_g ← clip( f_g + Δf_g(bp) + Δf_g(oja),  0, f_max )

3) 발화 역치 SP  (횟수·강도 기반 홈오스테틱)
r_t = F                           // 발화 "횟수"
m_t = F · [ (Z − SP) / Z_ref ]_+  // 발화 "강도"(여유 마진)

\bar r ← (1−β_r)·\bar r + β_r·r_t
\bar m ← (1−β_m)·\bar m + β_m·m_t

SP ← SP + η_SP · ( λ_r·(\bar r − r*)  +  λ_m·(\bar m − m*) )

[파라미터]
η_bp,w, η_bp,f  > 0        // 역전파 학습률
η_w, η_f        > 0        // Oja 국소항 학습률
w_max, f_max    > 0        // 가중치 상한
Z_ref, Y_ref    > 0        // 정규화 스케일
β_r, β_m ∈ (0,1]          // EMA 계수
r*, m* ∈ [0,1]            // 목표 발화율·강도
η_SP > 0,  λ_r, λ_m ≥ 0   // SP 업데이트 계수

---------------------------------------------------------------------------------

최종 퍼셉트론 기본 설계

[입력]

* 특징 벡터: X1, X2, ..., Xd
* 선택: Index 경로(토큰 입력) tok ∈ {0..V−1}
* 배치·시간 평탄화 축: b=1..B* (B*=B·T 또는 B)

[가중합]

* Dense: Z = Σ(k=1..d) X_k · w_k
* Index: Z = W_tok  // tok에 해당하는 단일 열 가중치

[발화 기준]

* 발화 역치 SP

[판정]

* Z ≥ SP → 발화
* Z < SP → 비발화 → f_g·Z 계산하지 않음(출력 없음)

[발화한 경우의 출력/전달]

* 활성화: Y_g = f_g · Z,  g = 1..α
  (α: 현재 퍼셉트론의 출력이 연결되는 다음 퍼셉트론의 수)
* 출력 벡터: Y = [Y_1, Y_2, ..., Y_α]

[순전파]
Z = {
  Dense: Σ_k X_k · w_k
  Index: W_tok
}
F = 1[ Z ≥ SP ]
Y_g = F · f_g · Z    // g = 1..α

[역전파]  // 상류 기울기 δ_g = ∂L/∂Y_g 가 주어졌다고 가정
S = Σ_g (δ_g · f_g)

∂L/∂f_g = δ_g · F · Z
∂L/∂Z   = F · S
∂L/∂w_k = (∂L/∂Z) · X_k = F · S · X_k
// Dense: ∂L/∂X_k = F · S · w_k
// Index: 입력이 정수(tok)라 ∂L/∂X_k = 0,  X_k=1(k=tok),0(그 외) ⇒ ∂L/∂W_tok = F · S

업데이트 집합 마스크(M_W, M_f):

* M_W, M_f ∈ {all, active, inactive},  active = (배치 평균 F>0인 뉴런)
* 행별 적용(⊙row):
    (∂L/∂w_k) ← (M_W ⊙row) · (∂L/∂w_k),    (∂L/∂f_g) ← (M_f ⊙row) · (∂L/∂f_g)

// 선택적 STE: F를 F+STE(U−SP)로 대체 가능. 이때 ∂L/∂SP ≠ 0.

[업데이트]
clip(a,l,h) = min(max(a,l), h)
안정화 상수: ε_Z>0, ε_Y>0,  Z_ref2 = Z_ref^2+ε_Z,  Y_ref2 = Y_ref^2+ε_Y

1. 입력 가중치 w_k  (역전파 + Oja 정규화, 발화 시만)
   Δw_k(bp)  = − η_bp,w · (∂L/∂w_k)
   Δw_k(oja) =  F · η_w · ( Z · X_k  −  (Z^2 / Z_ref2) · w_k )
   w_k ← clip( w_k + (M_W ⊙row)·Δw_k(bp) + Δw_k(oja),  w_min, w_max )

// Index 특기: k=tok에서만 갱신. 즉
ΔW_tok(bp)  = − η_bp,w · (F · S)
ΔW_tok(oja) =   F · η_w · ( Z · 1 − (Z^2 / Z_ref2) · W_tok )

2. 출력 가중치 f_g  (역전파 + Oja 정규화, 발화 시만)
   Δf_g(bp)  = − η_bp,f · (∂L/∂f_g)  = − η_bp,f · (δ_g · F · Z)
   Δf_g(oja) =   F · η_f · ( Y_g · Z  −  (Y_g^2 / Y_ref2) · f_g )
   f_g ← clip( f_g + (M_f ⊙row)·Δf_g(bp) + Δf_g(oja),  f_min, f_max )

3. 발화 역치 SP  (횟수·강도 기반 홈오스테틱)
   r_t = F                           // 발화 “횟수”
   m_t = F · [ (Z − SP) / (Z_ref + ε_Z) ]_+  // 발화 “강도”(여유 마진)

\bar r ← (1−β_r)·\bar r + β_r·r_t
\bar m ← (1−β_m)·\bar m + β_m·m_t

SP ← clip( SP + η_SP · ( λ_r·(\bar r − r*)  +  λ_m·(\bar m − m*) ),  SP_min, SP_max )

[파라미터]
η_bp,w, η_bp,f  > 0        // 역전파 학습률
η_w, η_f        > 0        // Oja 국소항 학습률
w_min, w_max    // 가중치 범위. 기본 0, w_max. 음수 허용 시 w_min = −w_max
f_min, f_max    // 출력 가중치 범위. 기본 0, f_max. 음수 허용 시 f_min = −f_max
Z_ref, Y_ref    > 0        // 정규화 스케일
ε_Z, ε_Y        > 0        // 분모 안정화
β_r, β_m ∈ (0,1]          // EMA 계수
r*, m* ∈ [0,1]            // 목표 발화율·강도
η_SP > 0,  λ_r, λ_m ≥ 0   // SP 업데이트 계수
SP_min < SP_max           // SP 클리핑 범위

// 구현 규칙: Oja·EMA 계산은 fp32, U/F/Y는 detach 스냅샷 사용. Dense/Index 모두 위 식에 따름.

---------------------------------------------------------------------------------------------------

퍼셉트론 

[입력]

* 특징 벡터: X1, X2, ..., Xd
* 선택: Index 경로(토큰 입력) tok ∈ {0..V−1}
* 배치·시간 평탄화 축: b = 1..B* (B* = B·T 또는 B)

[가중합]

* Dense 경로:

  * Z = Σ(k=1..d) X_k · w_k
* Index 경로:

  * Z = W_tok   // tok에 해당하는 단일 열 가중치

[발화 기준]

* 발화 역치 SP

[판정]

* Z ≥ SP → 발화
* Z < SP → 비발화 → f_g·Z 계산하지 않음(출력 없음)

[발화한 경우의 출력/전달 (로컬)]

* 활성화: Y_g = f_g · Z,  g = 1..α
  (α: 현재 퍼셉트론의 출력이 연결되는 다음 퍼셉트론의 수)
* 출력 벡터: Y = [Y_1, Y_2, ..., Y_α]

[순전파 (로컬 퍼셉트론 수준)]

Z = {
  Dense: Σ_k X_k · w_k
  Index: W_tok
}

F = 1[ Z ≥ SP ]        // 발화 여부 (0 또는 1)
Y_g = F · f_g · Z      // g = 1..α

여기까지가 한 퍼셉트론의 순간 시점(t)에서의 로컬 동작.

---

[시간축 Low-Rank Cross-Path SSM (선택 모듈, 경로 간 저랭크 상호작용)]

여기서는 P개의 퍼셉트론이 병렬로 존재한다고 가정하고,
각 시점 t마다 각 퍼셉트론 p의 발화 메시지를 시간축으로 누적하는 모듈을 정의.

* 시점 t 에서 각 퍼셉트론 p의 전위/발화:

  * Z_{t,p} : p번째 퍼셉트론의 전위
  * F_{t,p} = 1[ Z_{t,p} ≥ SP_p ]
  * t_{t,p} = F_{t,p} · Z_{t,p}

* 경로 메시지 벡터:

  * t_t = [t_{t,1}, t_{t,2}, ..., t_{t,P}] ∈ ℝ^P
  * F_t = [F_{t,1}, ..., F_{t,P}] ∈ {0,1}^P

1. 저랭크 투영 (P_r ≪ P)

r_t = t_t · V_r

* V_r ∈ ℝ^{P×P_r}
* r_t ∈ ℝ^{P_r}

2. 망각 게이트 및 상태 업데이트

a_t = σ(r_t · W_λ + b_λ)

* W_λ ∈ ℝ^{P_r×P_r}, b_λ ∈ ℝ^{P_r}
* a_t ∈ (0,1)^{P_r}
* 실 구현에서는 a_t를 [a_min, a_max] 범위로 clamp (예: 0.01 ~ 0.995)

상태:

s_t = a_t ⊙ s_{t-1} + (F_t ⊙ t_t) · V_b

* s_t ∈ ℝ^{P_r}, s_0는 0 또는 학습 초기값
* V_b ∈ ℝ^{P×P_r}
* (F_t ⊙ t_t)는 발화한 경로의 신호만 사용 → 비발화 경로는 상태에 기여하지 않음
* 필요 시 주입 규모 안정화를 위해
  (F_t ⊙ t_t) · V_b / √P_r  형태로 스케일링

(선택) 상태 정규화:

s_t ← s_t / RMS(s_t)

* RMS(s_t) = sqrt( mean(s_t^2) + ε ), ε>0

3. 경로 공간 복귀 (저랭크 상태 → 경로 신호)

t̃_t = s_t · V_o

* V_o ∈ ℝ^{P_r×P}
* t̃_t ∈ ℝ^P, 성분 t̃_{t,p}는 “시간·경로 문맥이 반영된 p번째 경로 신호”

4. SSM 출력의 사용

* t̃_t 는 Low-Rank Cross-Path SSM을 거친 문맥 강화 경로 신호로,
  다음 레이어(또는 추가 라우팅/선형층)의 입력으로 사용:

예:

* 다음 계층 입력: X_{next,t} = t̃_t
* 또는, 경로별 출력 가중치와 결합:
  Y^{SSM}*{t,p,g} = F*{t,p} · f_{p,g} · t̃_{t,p}

※ 여기서도 F_{t,p}를 곱하면, 현재 시점에 발화한 퍼셉트론만 실제 출력 Y를 갖는다는 원래 철학을 유지 가능.
(SSM은 상태 s_t와 t̃_t를 통해 문맥을 보강하지만, 최종 출력 단계에서 F가 다시 적용되므로, 비발화 퍼셉트론은 출력 0 유지.)

※ 역전파 관점에서는 SSM 모듈이 L → t̃_t → s_t → t_t 로 체인 룰로 기울기를 전달하며,
위의 “로컬 퍼셉트론 역전파/업데이트 식”에서 쓰이는 δ_g = ∂L/∂Y_g 는
SSM을 포함한 상위 계층 전체의 영향을 포함한 값으로 간주.

---

[역전파]  // 상류 기울기 δ_g = ∂L/∂Y_g 가 주어졌다고 가정
(여기서 Y_g 는 위 SSM 사용 여부와 관계없이, 로컬 퍼셉트론 출력에 대한 기울기로 해석)

S = Σ_g (δ_g · f_g)

∂L/∂f_g = δ_g · F · Z
∂L/∂Z   = F · S
∂L/∂w_k = (∂L/∂Z) · X_k = F · S · X_k

// Dense: ∂L/∂X_k = F · S · w_k
// Index: 입력이 정수(tok)라 ∂L/∂X_k = 0,
//        X_k=1(k=tok),0(그 외) ⇒ ∂L/∂W_tok = F · S

업데이트 집합 마스크(M_W, M_f):

* M_W, M_f ∈ {all, active, inactive},  active = (배치 평균 F>0인 뉴런)
* 행별 적용(⊙row):
    (∂L/∂w_k) ← (M_W ⊙row) · (∂L/∂w_k),
    (∂L/∂f_g) ← (M_f ⊙row) · (∂L/∂f_g)

// 선택적 STE: F를 F+STE(U−SP)로 대체 가능. 이때 ∂L/∂SP ≠ 0.

---

[업데이트]
clip(a,l,h) = min(max(a,l), h)
안정화 상수: ε_Z>0, ε_Y>0,  Z_ref2 = Z_ref^2+ε_Z,  Y_ref2 = Y_ref^2+ε_Y

1. 입력 가중치 w_k  (역전파 + Oja 정규화, 발화 시만)

   Δw_k(bp)  = − η_bp,w · (∂L/∂w_k)
   Δw_k(oja) =   F · η_w · ( Z · X_k  −  (Z^2 / Z_ref2) · w_k )

   w_k ← clip( w_k + (M_W ⊙row)·Δw_k(bp) + Δw_k(oja),  w_min, w_max )

   // Index 특기: k=tok에서만 갱신. 즉
   ΔW_tok(bp)  = − η_bp,w · (F · S)
   ΔW_tok(oja) =   F · η_w · ( Z · 1 − (Z^2 / Z_ref2) · W_tok )

2. 출력 가중치 f_g  (역전파 + Oja 정규화, 발화 시만)

   Δf_g(bp)  = − η_bp,f · (∂L/∂f_g)  = − η_bp,f · (δ_g · F · Z)
   Δf_g(oja) =   F · η_f · ( Y_g · Z  −  (Y_g^2 / Y_ref2) · f_g )

   f_g ← clip( f_g + (M_f ⊙row)·Δf_g(bp) + Δf_g(oja),  f_min, f_max )

3. 발화 역치 SP  (횟수·강도 기반 홈오스테틱)

   r_t = F                           // 발화 횟수
   m_t = F · [ (Z − SP) / (Z_ref + ε_Z) ]_+  // 발화 강도(여유 마진)

   \bar r ← (1−β_r)·\bar r + β_r·r_t
   \bar m ← (1−β_m)·\bar m + β_m·m_t

   SP ← clip( SP + η_SP · ( λ_r·(\bar r − r*)  +  λ_m·(\bar m − m*) ),  SP_min, SP_max )

---

[파라미터]

* η_bp,w, η_bp,f  > 0        // 역전파 학습률
* η_w, η_f        > 0        // Oja 국소항 학습률
* w_min, w_max    // 가중치 범위. 기본 0, w_max. 음수 허용 시 w_min = −w_max
* f_min, f_max    // 출력 가중치 범위. 기본 0, f_max. 음수 허용 시 f_min = −f_max
* Z_ref, Y_ref    > 0        // 정규화 스케일
* ε_Z, ε_Y        > 0        // 분모 안정화
* β_r, β_m ∈ (0,1]          // EMA 계수
* r*, m* ∈ [0,1]            // 목표 발화율·강도
* η_SP > 0,  λ_r, λ_m ≥ 0   // SP 업데이트 계수
* SP_min < SP_max           // SP 클리핑 범위

// 구현 규칙:
// - Oja·EMA 계산은 fp32에서 수행
// - U/F/Y, t, s_t 는 autograd 그래프 밖에서 detached 스냅샷을 사용
// - Dense/Index 경로 모두 위 식에 따르되, Index에서는 ∂L/∂X=0, ∂L/∂W_tok만 존재

---


